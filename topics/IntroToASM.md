# INTRO TO BASIC ASM STRUCTURE

So whenever a source code is compiled, it is converted into object files so that i can be ran by ASM

To create an exploit we need to know about the basic structure of an object file

## OBJECT FILES

An object code is the representation of the source code in "binary format"

An object file can contain many data like

	- The actual binary program data
	- Symbol table
	- Relocation information
	- Other elements & etc..

Runtime operations and Symbol Resolutions are performed by "loader and linker" from an object file

### LINKER 

Responsible for resolving the location of wanted functions from the system library which are needed by the object file

It has the primary responsibilty of symbol resolution, taking the symbolic name of a function and linking it to its actual location

	Example:
		When printf() is being called
		Linker is responsible for locating the memory address of that function from a system library 
		Then populating a writable area in memory with the address inside the process

### LOADER

Loader is used to load an object file into memory at the wanted load addressing as well as to map various segments

Loaders are responsible for loading a program from disk or anysecondary storage into memory

Multiple segments are mapped and created in memory during program/binary runtime

The primary segments are the code segment, stack segment, data segment, heap, and Block Started by Symbol (BSS)

## CODE SEGMENT

The code segment (CS), as with the data segment and BSS segment, is of fixed size

Space/Memory size "cannot be allocated" into these segments without the potential for affecting the proper functionality of the program

The code segment is set up with "read and execute permissions"

The "write permission is disabled" because it contains the program's instructions as interpreted by the compiler

## DATA SEGMENT

The data segment (DS) contains "initialized global variables"

Eg: 
```
char Aiden[6]="Monish";
```

These are variables that were defined by the "programmer"

Segment registers DS, ES, FS, and GS can all map to different areas within memory

## BLOCK STARTED BY SYMBOL (BSS)

BSS contains "uninitialized global variables"

Eg: 
```
char Aiden[6];
```

Any variable with a value of zero upon runtime may reside in the BSS segment

Some compilers will not store these uninitialized variables in the BSS segment if it is determined that they are blocks of dead code that are unused

## MEMORY LAYOUT

	-----Higher Memory Address-----
	Argc Argv
	ENV Pointers
	Stack (growing downwards)
	Heap (growing upwards)
	.BSS
	.Text
	Shared Libraries
	-----Lower Memory Address-----

## STACK SEGMENT

Refer more about [Stack](https://github.com/AidenPearce369/ExploitDev/blob/main/Memory_Structure.md#stack)
The stack segment is leveraged when function calls are made

The state of the process before a function is called is pushed onto the stack through a series of short operations known as the procedure "PROLOGUE"

Stack growth is done by nested function calls and more instructions

Each function gets its own memory frame in Stack

The stack often holds finite memory allocations associated with function calls, as well as arguments relative to a called function

Many functions return values back to the caller through the use of the EAX/RAX register, as well as other registers and memory locations

## HEAP SEGMENT

Refer about [Heap](https://github.com/AidenPearce369/ExploitDev/blob/main/Memory_Structure.md#heap)

Applications performing large memory allocations to hold user data or run feature-rich content heavily utilize the heap

The heap is designed to border a large, unused memory segment to allow it to grow without interfering with other memory segments

### NOTE

Stack and Heap , both grows toward each other

But they are far way , because we need to ensure that Stack and Heap does not collide

Stack starts from higher memory and grow towards lower memory

Heap starts from lower memory and grow towards higher memory

Stack always used two pointers

	- Stack Pointer (SP)
	- Base Pointer (BP)

Stack Pointer (SP) points the top of the current stack frame

Base Pointer (BP) is used as a reference pointer to access all the local variables and arguments of the stack frame

CPU access all of the data used to process from the stack frame using BP registers

-----

## CALLING CONVENTIONS

Calling conventions are used to pass data to the called functions or retrieve data from the function return

More about [Calling Convention](https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions)

Commonly used calling conventions are,

	- cdecl
	- stdcall

### CDECL

It is common in C programs

Parameters or arguments are passed to "Called function" in "right to left" order on the stack

"Calling function" is responsible for tearing down the stack

EAX register is used to return values to the caller

Procedure epilogue data is automatically added to the program during compile time to handle the tearing down of the stack
	
### STDCALL

Similar like cdecl, commonly used in C programs

Parameters or arguments are passed to "Called function" in "right to left" order on the stack

"Called function" is responsible for tearing down the stack when the function is completed

EAX register is again used to return values from the called function back to the caller


Other commonly used calling functions are,

	- syscall
	- fastcall
	- optlink and so on..

-----

## SYMBOLS

Symbols are a symbolic reference to a global variable or function

For instance, the printf() function is going to have a symbol entry that points to it in the dynamic symbol table .dynsym

There are two symbol tables: .dynsym and .symtab

.symtab contains all of the symbols, whereas .dynsym contains just the dynamic/ global symbols from an external source

The .dynsym section will be allocated at runtime and loaded into memory, and .symtab is not loaded into memory because it is not necessary for runtime

The .dynsym symbol table is necessary for the execution of dynamically linked executables, the .symtab symbol table exists only for debugging and linking purposes and is often ignore to save space

-----

## RELOCATION

Relocation is the process of connecting symbolic references with symbolic definitions

Relocatable file must have information that describes how to modify their section contents, thus allowing executable and shared object files to hold the right information for a processâ€™s program image

Relocation entries are these data and their struct are Elf32_Rel or Elf32_Rela

```

typedef struct{
	Elf32_Addr	r_offset;
	Elf32_Word	r_info;
}	Elf32_Rel;

typedef struct{
	Elf32_Addr	r_offset;
	Elf32_Word	r_info;
	Elf32_Sword	r_addend;
}	Elf32_Rela;

```

The "r_offset" gives the location at which to apply the relocation action

A relocation action describes how to patch the code or data contained at "r_offset"

The "r_info" gives both the symbol table index with respect to which the relocation must be made and the type of relocation to apply

The "r_addend" specifies a constant addend used to compute the value stored in the relocatable field

If a shared object requests to be loaded to an area of memory that is already being used, there must be a control in place to allow the object to be loaded into a different area of memory, which is done by "relocation"

".reloc" section provides the values for relocation

If the load address is unavailable, the relocation section "patches the program to the new addressing"

Functions are referenced by "Relative Virtual Addresses (RVAs)"

	Example:
	Lets consider a function name exploit()
	The RVA for exploit is X
	And the Load Address of the program in runtime is Y
	So to call the function the True Address of exploit is X+Y
	When X+Y is unvailable(used for other process), relocation plays here
	New Load address is generated using relocation (assume X')
	True Address of exploit() becomes X'+Y
	The True Address of exploit() is relocated to here and patched
	So the function can be called using the new address

On Windows the process of relocation is known as "fix-ups"

Fix-ups are almost never needed on Modern Windows systems, as each program is given its own address space

Modern Linux systems also rarely have the need to relocate an ELF file. Shared libraries sometimes need relocation, but desired addressing is almost always available

The support for relocation must be within the object file in the event it is needed.

-----

## NAME MANGLING

The name of a function or other procedure/construct in a program's source code will often not be the same name
seen in symbol tables and the like

Common method used by decompilers and debuggers

	Example:
	main( function in source code can be viewed as _main() in debuggers and decompilers

C language does not have polymorphism(name overloading), so name mangling on C is not used

Name mangling is done to avoid collision within the programs due to same name

-----

## EXECUTABLE AND LINKING FORMAT (ELF)

ELF is an object file format used by many UNIX OSs to support "dynamic linking", "symbol resolution", and many other functions

ELF file contains a set of sections used by the linker where the object file contains

	-machine code of the executable program
	-symbols that need to be imported
	-functions that can be exported
	-debugging information
	-relocation information
	-header file

ELF file can be mapped directly into memory at runtime

Allows for relative addressing to remain while changing the load address

### RELOCATABLE ELF 

Relocatable ELF files contain multiple sections, such as object code, data, symbols having or needing resolution, a magic number, and various other sections

These sections are contained within the ELF header file

A relocatable file allows for the relative address of a mapped section or symbol to be maintained, while modifying the base address in the event there may be a conflict

	Example:
	if the relative address of a function called
	get_star() is 0x1000 and it was expecting to be mapped to the base address 0x02000000, the absolute address in that instance would be 0x02001000. However, if the file is in relocatable format, the base address could be relocated to a new base address, such as 0x08040000, resulting in the absolute address of 0x02012000(random)

### EXECUTABLE ELF

Executable ELF files are relatively close to the format of relocatable ELF files

The primary difference is the capability for an executable ELF file to be mapped directly into memory upon execution which is not being relocated

Executable ELF files have been optimized by including only the necessary sections, including read-only code, data, BSS, virtual addressing information, and some other relevant information

-----

## SHARED OBJECTS

A shared object is simply a library of functions available to developers which can be shared by programs on runtime

A dynamically compiled program relies on system libraries contained on a target system

These libraries are loaded into a program during startup, and the function names within them are dynamically
resolved as required

An ELF shared object file contains the elements of both relocatable files and executable files

It contains the program header file contained in an ELF executable file, loadable sections, and the additional linking information contained in relocatable files

----

## PROCEDURE LINKAGE TABLE (PLT)

Procedure Linkage Table(PLT) is a "read-only" section

It is responsible for calling the dynamic linker during and after the program runtime to resolve the addresses of the requested functions

During compilation we cannot mention these addresses because the function addresses of each system is unknown and shared object is also unavailable

So,PLT plays a vital role in resolving these function addresses during runtime

PLT table is much larger than the GOT table

Each program/binary has its own PLT table which is useful to itself only

When symbol resolution is requested, the request is made to the PLT by the calling function, and the address of the GOT is pushed into a processor register

This is how shared library functions are called via binaries

-----

## GLOBAL OFFSET TABLE (GOT)

Global Offset Table(GOT) is popped by a dynamic linker during programming runtime

Dynamic linker obtains the absolute addresses of requested functions and updates the GOT as requested

Files do not need to be relocatable because the GOT takes requests for locations from the Procedure Linkage Table
(PLT)

Many functions will not be resolved at runtime and get resolved only on the first call to the requested
function

This is a process known as "lazy linking", which saves on resources

-----









